# UAVTalk

UAVTalk is a highly efficient, extremely flexible and completely open binary protocol designed specifically for communication with UAVs. It is licensed under the Creative Commons BY-SA license so it can be implemented in commercial as well as Free software. See [LibrePilot's UAVTalk reference](https://librepilot.atlassian.net/wiki/display/LPDOC/UavTalk)


The UAVTalk protocol allows communication between the flight controller and the raspberry pi via the transport of datastructures defined by UAVObjects. To make the addition of new UAVObjects easier, the UAVTalk protocol doesn't need to know the details of the data structure, instead UAVTalk is only responsible for sending byte arrays and routing recieved byte arrays to the correct object for unpacking.

A UAVTalk message is specified as follows:

| Field | Length(bytes) | Value |
|---|---|---|
| Sync Val | 1 | 0x3C|
| Message Type | 1 | Lower nibble specifies kind of message, higher nibble indicates protocol |
| Length | 2 | Length of header and data, not checksum |
| Object ID | 4 | Unique object ID, generated by parser |
| Instance ID | 2 | Unique  object instance ID. 0 for single instance UAVObjects |
| Timestamp | 2 | Unused for our implementation |
| Data | 0-255 | Serialized (packed) object. The length of data is identified by ObjectID. |
| Checksum | 1 | CRC-8 checksum (Header and Data) |

##### Explanation of Message Type:
Lower nibble means the kind of message:
* 0x0 Object Data (OBJ) 
* 0x1 Object request (OBJ_REQ)
* 0x2 Object with acknowledge request (OBJ_ACK)
* 0x3 Acknowledge (ACK)
* 0x4 Negative-Acknowledge (NACK) 

Higher nibble has the following meaning
* bits 5-7 Protocol version ( current version is 2, 0x20)
* bit 8 (0x80) indicates a timestamped message. (unused for our implementation)

##### Object ID

The object ID is a unique 32-bit integer identifying the object the message data represent. The UAVTalk layer routes all received payloads to the appropriate object for unpacking. The object ID is automatically generated by the parser by applying a hash on the XML definition of the object. This has two advantages, first the ID is unique (very small probability of collision exists but it is insignificant) so there is no need for a centralized database of IDs, objects can be added without worrying about choosing a unique ID. Second each time the object definition is changed the ID will also change, this is a convenient way to make sure that UAVObjects on the GCS and autopilot have the same definition (i.e. have the same version). The ObjectIDs for relevant UAVObjects are defined in `UAVTalk.h`. For a complete list of object XML definitions, please see [LibrePilot's git repository](https://github.com/librepilot/LibrePilot/tree/next/shared/uavobjectdefinition).
